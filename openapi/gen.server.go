// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.1 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 获取所有数据源列表
	// (GET /api/v1/sources)
	DMAPIGetSourceList(ctx echo.Context) error
	// 创建新的数据源
	// (POST /api/v1/sources)
	DMAPICreateSource(ctx echo.Context) error
	// 删除数据源
	// (DELETE /api/v1/sources/{source-name})
	DMAPIDeleteSource(ctx echo.Context, sourceName string) error
	// 为数据源开启 relay log 功能
	// (PATCH /api/v1/sources/{source-name}/start-relay)
	DMAPIStartRelay(ctx echo.Context, sourceName string) error
	// 查询数据源的当前状态
	// (GET /api/v1/sources/{source-name}/status)
	DMAPIGetSourceStatus(ctx echo.Context, sourceName string) error
	// 为数据源关闭 relay log 功能
	// (PATCH /api/v1/sources/{source-name}/stop-relay)
	DMAPIStopRelay(ctx echo.Context, sourceName string) error
	// 获取当前所有任务的信息
	// (GET /api/v1/tasks)
	DMAPIGetTaskList(ctx echo.Context) error
	// 提交并开始任务
	// (POST /api/v1/tasks)
	DMAPIStartTask(ctx echo.Context) error
	// 删除任务
	// (DELETE /api/v1/tasks/{task-name})
	DMAPIDeleteTask(ctx echo.Context, taskName string) error
	// 查询任务当前状态
	// (GET /api/v1/tasks/{task-name}/status)
	DMAPIGetTaskStatus(ctx echo.Context, taskName string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// DMAPIGetSourceList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceList(ctx)
	return err
}

// DMAPICreateSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPICreateSource(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPICreateSource(ctx)
	return err
}

// DMAPIDeleteSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteSource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteSource(ctx, sourceName)
	return err
}

// DMAPIStartRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStartRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStartRelay(ctx, sourceName)
	return err
}

// DMAPIGetSourceStatus converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceStatus(ctx, sourceName)
	return err
}

// DMAPIStopRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStopRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStopRelay(ctx, sourceName)
	return err
}

// DMAPIGetTaskList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskList(ctx)
	return err
}

// DMAPIStartTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStartTask(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStartTask(ctx)
	return err
}

// DMAPIDeleteTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteTask(ctx, taskName)
	return err
}

// DMAPIGetTaskStatus converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskStatus(ctx, taskName)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/sources", wrapper.DMAPIGetSourceList)
	router.POST(baseURL+"/api/v1/sources", wrapper.DMAPICreateSource)
	router.DELETE(baseURL+"/api/v1/sources/:source-name", wrapper.DMAPIDeleteSource)
	router.PATCH(baseURL+"/api/v1/sources/:source-name/start-relay", wrapper.DMAPIStartRelay)
	router.GET(baseURL+"/api/v1/sources/:source-name/status", wrapper.DMAPIGetSourceStatus)
	router.PATCH(baseURL+"/api/v1/sources/:source-name/stop-relay", wrapper.DMAPIStopRelay)
	router.GET(baseURL+"/api/v1/tasks", wrapper.DMAPIGetTaskList)
	router.POST(baseURL+"/api/v1/tasks", wrapper.DMAPIStartTask)
	router.DELETE(baseURL+"/api/v1/tasks/:task-name", wrapper.DMAPIDeleteTask)
	router.GET(baseURL+"/api/v1/tasks/:task-name/status", wrapper.DMAPIGetTaskStatus)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
