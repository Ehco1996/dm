// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.2 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get data source list
	// (GET /api/v1/sources)
	DMAPIGetSourceList(ctx echo.Context) error
	// create new data source
	// (POST /api/v1/sources)
	DMAPICreateSource(ctx echo.Context) error
	// delete a data source
	// (DELETE /api/v1/sources/{source-name})
	DMAPIDeleteSource(ctx echo.Context, sourceName string) error
	// enable relay log function for the data source
	// (PATCH /api/v1/sources/{source-name}/start-relay)
	DMAPIStartRelay(ctx echo.Context, sourceName string) error
	// get the current status of the data source
	// (GET /api/v1/sources/{source-name}/status)
	DMAPIGetSourceStatus(ctx echo.Context, sourceName string) error
	// disable relay log function for the data source
	// (PATCH /api/v1/sources/{source-name}/stop-relay)
	DMAPIStopRelay(ctx echo.Context, sourceName string) error
	// get task list
	// (GET /api/v1/tasks)
	DMAPIGetTaskList(ctx echo.Context) error
	// create and start task
	// (POST /api/v1/tasks)
	DMAPIStartTask(ctx echo.Context) error
	// delete and stop task
	// (DELETE /api/v1/tasks/{task-name})
	DMAPIDeleteTask(ctx echo.Context, taskName string) error
	// get task status
	// (GET /api/v1/tasks/{task-name}/status)
	DMAPIGetTaskStatus(ctx echo.Context, taskName string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// DMAPIGetSourceList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceList(ctx)
	return err
}

// DMAPICreateSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPICreateSource(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPICreateSource(ctx)
	return err
}

// DMAPIDeleteSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteSource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteSource(ctx, sourceName)
	return err
}

// DMAPIStartRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStartRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStartRelay(ctx, sourceName)
	return err
}

// DMAPIGetSourceStatus converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceStatus(ctx, sourceName)
	return err
}

// DMAPIStopRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStopRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStopRelay(ctx, sourceName)
	return err
}

// DMAPIGetTaskList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskList(ctx)
	return err
}

// DMAPIStartTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStartTask(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStartTask(ctx)
	return err
}

// DMAPIDeleteTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteTask(ctx, taskName)
	return err
}

// DMAPIGetTaskStatus converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskStatus(ctx, taskName)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/sources", wrapper.DMAPIGetSourceList)
	router.POST(baseURL+"/api/v1/sources", wrapper.DMAPICreateSource)
	router.DELETE(baseURL+"/api/v1/sources/:source-name", wrapper.DMAPIDeleteSource)
	router.PATCH(baseURL+"/api/v1/sources/:source-name/start-relay", wrapper.DMAPIStartRelay)
	router.GET(baseURL+"/api/v1/sources/:source-name/status", wrapper.DMAPIGetSourceStatus)
	router.PATCH(baseURL+"/api/v1/sources/:source-name/stop-relay", wrapper.DMAPIStopRelay)
	router.GET(baseURL+"/api/v1/tasks", wrapper.DMAPIGetTaskList)
	router.POST(baseURL+"/api/v1/tasks", wrapper.DMAPIStartTask)
	router.DELETE(baseURL+"/api/v1/tasks/:task-name", wrapper.DMAPIDeleteTask)
	router.GET(baseURL+"/api/v1/tasks/:task-name/status", wrapper.DMAPIGetTaskStatus)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"IrIgr1oduiIn14w+2d3s/hMAAP//4AYh2Ew/AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
